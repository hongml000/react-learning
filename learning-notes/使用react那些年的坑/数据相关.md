# 表格从redux中获取值，未及时更新
原因：数据结构复杂，深层数据改变时，因对象引入地址未改变，所以监听不到数据的变化

## 数据的引申
### 对象
对象拷贝时，如果使用扩展运算符（...）或Object.assign({}, data)只会改变最外层的引用地址，所以我们在做数据双向绑定时，常常用到这个方法，只要最外层的引用地址改变了，就能触发重新渲染
```js
let a = {
  x: 1,
  y: {z: 2}
}
let b = Object.assign({}, a)    // 效果同: let b = {...a}
// 当赋值时：
// a -> x
//   -> y -> z

// b -> x1
//   -> y1 -> z

b.x = 2
console.log(a.x)  // 1
console.log(b.x)  // 2
// 值不等，是因为指向的x的地址已经不同

b.y.z = 3;
console.log(a.y.z)  // 3
console.log(b.y.z)  // 3
// 值相等，是因为指向的z的地址相同

b.y = {z: 4}
console.log(a.y)  // {z:3}
console.log(b.y)  // {z:4}
// 会发现，a和b的x值和y值并不相等，是因为b改变了x和y的引用地址，而b.y改变了指向z的地址
// a -> x -> z
//   -> y -> z

// b -> x1
//   -> y1 -> z1

```
### 数组拷贝
推荐使用map,filter,reducer等方法，因为会生成一个新的数组，而不会改变原数据

## 回归问题
往往我们更改深层数据时：
```obj.tt.cc.ss = {a: "bb"}```
因为数据过于深层，最外层地址未改变，react会认为数据未有改变，所以不会触发重新渲染
```js
// 原来:
obj.tt.cc.ss = {a: "bb"}
update(obj)

// 修改:
newObj = Object.assign({}, obj)
newObj.tt.cc.ss = {a: "bb"}
update(newObj)
```